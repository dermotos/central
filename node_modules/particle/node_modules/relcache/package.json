{
  "name": "relcache",
  "description": "In memory cache for relationships.",
  "version": "0.1.2",
  "homepage": "http://github.com/TorchlightSoftware/relcache",
  "repository": {
    "type": "git",
    "url": "git://github.com/TorchlightSoftware/relcache.git"
  },
  "author": {
    "name": "Torchlight Software",
    "email": "info@torchlightsoftware.com",
    "url": "http://torchlightsoftware.com"
  },
  "main": "./index.js",
  "dependencies": {
    "ale": "*",
    "torch": "*",
    "lodash": "*",
    "coffee-script": "*"
  },
  "devDependencies": {
    "mocha": "*",
    "should": "*"
  },
  "engines": {
    "node": ">= 0.8.4"
  },
  "licenses": [
    {
      "type": "MIT",
      "url": "http://github.com/torchlightsoftware/relcache/raw/master/LICENSE"
    }
  ],
  "scripts": {
    "test": "mocha"
  },
  "readme": "# relcache\n\nA cache for relationships so you don't have to round trip to the DB in order to look them up.\n\nRelationships are stored bi-directionally, and can be searched with a 'find' function.\n\nThe information is stored in a nested hash, so lookups are fast.  The data points are either single values, or Arrays which follow 'set' data structure rules, courtesy of lodash.  (i.e. they don't contain duplicate values, and we can remove items from the lists and perform unions reliably)\n\n# Storage Operators\n\n## Set\n\nSet stores many-1 relationships.  The relationships provided in the third arg are assumed to be unique to the key.  If you set the same name again, the value will be overwritten and the reverse lookup will be updated.\n\nThe first two arguments are a key and value which represent the left side of the relationship.  The third argument is a hash.  In practice this lets you set multiple relationships in one call.\n\nUse 'set' to store the fields within a record:\n\n```coffee-script\nrelcache.set \"user._id\", 5, {name: 'Fred', email: 'fred@foo.com'}\n\n# direct lookup\nrelcache.get \"user._id\", 5                  # {name: 'Fred', email: 'fred@foo.com'}\n\n# reverse lookup\nrelcache.get \"user.name\", 'Fred'            # {user._id: [5]}\nrelcache.get \"user.email\", 'fred@foo.com'   # {user._id: [5]}\n```\n\nThe many-1 relationship in this case means many IDs could point to the same name:\n\n```coffee-script\nrelcache.set \"user._id\", 5, {name: 'Fred'}\nrelcache.set \"user._id\", 7, {name: 'Fred'}\n\nrelcache.get \"user.name\", 'Fred' # {user._id: [5, 7]}\n```\n\n## Add\n\nAdd stores many-many relationships.  If you add two relationships of the same name, the new values will be appended, not overwritten as in the case of 'set'.\n\nUse 'add' to store relationships between records:\n\n```coffee-script\n# many to many between chats and users\nrelcache.add \"user._id\", 5, {chat._id: 1}\nrelcache.add \"user._id\", 5, {chat._id: 4}\nrelcache.add \"user._id\", 6, {chat._id: 4}\n\n# direct lookup\nrelcache.get \"user._id\", 5                  # {chat._id: [1, 4]}\nrelcache.get \"user._id\", 6                  # {chat._id: [4]}\n\n# reverse lookup\nrelcache.get \"chat._id\", 1                  # {user._id: [5]}\nrelcache.get \"chat._id\", 4                  # {user._id: [5, 6]}\n```\n\n# Query Operators\n\n## Get\n\nUse the get method to perform a lookup on key equality.\n\n```coffee-script\nrelcache.get \"user._id\", 5\n```\n\nYou can also specify fields by which to filter:\n\n```coffee-script\nrelcache.get \"user._id\", 5, 'name'\nrelcache.get \"user._id\", 5, ['name', 'email']\n```\n\n## Find\n\nThe find function is what you'll want to use if an equality comparitor doesn't cut it for your use case.  It supports [MongoDB's comparison operators](http://docs.mongodb.org/manual/reference/operator/#comparison).\n\n```coffee-script\n# many to many between chats and users\nrelcache.set \"user._id\", 5, {loginCount: 11}\nrelcache.set \"user._id\", 6, {loginCount: 8}\nrelcache.set \"user._id\", 7, {loginCount: 16}\nrelcache.set \"user._id\", 8, {loginCount: 11}\nrelcache.set \"user._id\", 9, {loginCount: 4}\n\nrelcache.find \"loginCount\", \"gte\", 10 # {user._id: [5, 7, 8]}\n```\n\nIf you want to store relationships between records, you'll probably want to use a many to many\n\n## LICENSE\n\n(MIT License)\n\nCopyright (c) 2013 Torchlight Software <info@torchlightsoftware.com>\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\nLIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\nOF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n",
  "readmeFilename": "README.md",
  "_id": "relcache@0.1.2",
  "dist": {
    "shasum": "796d43601f885657a64cc9ce67af2ad38c636e8d",
    "tarball": "http://registry.npmjs.org/relcache/-/relcache-0.1.2.tgz"
  },
  "_from": "relcache@*",
  "_npmVersion": "1.2.17",
  "_npmUser": {
    "name": "torchlight",
    "email": "info@torchlightsoftware.com"
  },
  "maintainers": [
    {
      "name": "torchlight",
      "email": "info@torchlightsoftware.com"
    }
  ],
  "directories": {},
  "_shasum": "796d43601f885657a64cc9ce67af2ad38c636e8d",
  "_resolved": "https://registry.npmjs.org/relcache/-/relcache-0.1.2.tgz"
}
